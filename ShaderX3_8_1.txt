这篇文章讨论一种渲染体容积光的技术，是一个对现有游戏使用技术的提升。这个技术基于面片的体渲染方法。这里我们会童工对Dobashi和Nishita技术的数个提升的方法，在ps_2_0着色器支持下可以实现。

场景中的容积光

一般来说，在实时3D图形中，我们使用简单雾模型和粒子系统去模拟光从漂浮在空中颗粒物中散射回来的效果。这些效果对给与我们对规模的感受和增强场景的真实感很重要，但我们可以在硬件上通过复杂的shader和高填充率做得更好。我们将在这章节实现的效果是发光颗粒物的可视化，或者"participating media"在我们的场景中。这些颗粒物密度可能不均匀并且需要有正确的场景阴影，如图8.1.1。
大多数游戏通过绘制容积光边界区域多边形来渲染容积光，这些多边形混合在场景中，当使用恰当的时候，能够给场景一种很好的空中发光颗粒物的感觉。这些多边形被一个随机纹理渲染、缓慢的UV动画来给出一种灰尘在空间中漂浮的感觉。
一些游戏会把金字塔型的光线通过更多的多边形来显示，当摄像机相对于容积光移动的时候这给予了一定的视差效果，因为体内的点被渲染了。渲染容积光的包围体时通常消耗都比较少，但一般没那么方便。这种幻觉在用户相对于容积光移动的时候会被破坏，特别是当容积光被camera的front plane剪裁的时候。
Mech01和James03研究了另外一类方法。这两篇文章讨论了通过增加和减去前后深度来计算特定体积的射线长度从而计算出漂浮物包围体的形状。这是很聪明的技术可以自然地整合在3D多边形场景中，但是他们不允许灯光颜色参数，不均匀的密度，或者复杂的阴影。
这节讨论的方法是基于科学可视化社区中使用的技术，特别是基于面片的体渲染。代替在世界空间和灯光空间中渲染特定的多边形来制作容积光，我们渲染相机空间中固定朝向的多边形以便沿着光线整合光量。
当场景其他部分都被渲染了，一系列垂直于视线方向的面片会被渲染，如图。这些面片通过add的方法渲染到framebuffer中以便积累场景中颗粒物通过每个像素光线摄像视点散射的光。
当你正常渲染的时候，你其实是计算每个给定像素散射到眼睛里面的光量，但你可以通过渲染正常的不透明多边形平面。在半透明体积数据如容积光的情况下，你应该沿着射线统计volume内所有散射的光。这是我们渲染一堆堆砌相机空间取样平面的原因，让你可以取样容积光体积的所有射线。
这些取样平面通过投影一些从光源来的贴图来渲染。这是为了近似每个像素射出射线上的积分，以及反过来，通过每个取样平面。最终结果应该是近似于光线从空中漂浮颗粒物散射到眼睛的光量。
为了我们的目的，我们光线模型是透视的（类似于手电筒和幻灯机）。每个灯光有坐标、方向、上向量，水平与垂直的视场角，以及远近裁面。简单来说每个光都有一个视椎体，就像一个普通3D场景的观察者一样。一个给定的光源只能在它视椎体里产生光。这很重要，因为它意味着我们只需要在视椎体里面取样了。
取样平面的顶点数据每帧都必须变换到眼镜空间的正确位置。这可以通过在vertex shader中进行简单的三线性插值来完成。取样平面的vertex buffer包含一定数量的在z轴上均匀分布切填满单位cube的quad（CD-ROM中的数量是100）。数据通过这种方式存储在vertex buffer中，就可以在vertex shader代码中简单地变换成填满相机空间包围盒的视锥空间。
这个对齐观察空间包围盒被加载到固定存储器中，并且着色器在这包围盒里三线性插值来放置每个顶点。这意味着这些平面定位非常轻巧，因为着色器能使用上述代码正确计算其位置。下图显示了光视锥和与视线垂直的取样平面（观察者在左边）。取样平面填满了与光视锥的view-space-aligned包围盒。

着色取样平面

现在我们沿着视线方向在光视锥中放置好了取样平面，我们应该怎么渲染他们呢。光照等式中有几项，每个都增加真实性和控制力：
光散射
遮罩
阴影
噪声/不均匀

第一项是最复杂的，用于描述假如漂浮物是均匀密度的话有多少光会到达我们的眼睛，剩下三项以不同的方式遮蔽散射光。

光散射

已经有很多人研究了光线如何在粒子中散布以及怎么影响我们看到的。我们都知道在广大户外场景中使用某些雾模型来营造正确的规模感。这在所有飞行模拟或者其他需要渲染大规模户外场景的3D应用中实现。最近，这些算法进一步推进，随着许多形式散射已被纳入可用的模型。不同的项如粒子密度，光和眼睛与特定粒子的距离，角度衰减都对散射到观察者的光量有影响。由于部分因素（如角度衰减）可以烘焙到cookie中（下节讲），而且因为我们打算渲染非均匀密度的粒子，我们忽略其他参数，除了1/distance平方这个光线强度衰减，这是光散射最重要的方面。你可以想象从一个给定粒子散射到我们眼睛的光量是乘以距离的平方，以及光照等式的其他项可能会影响到它。为了说明距离平方倒数的效果，下图展示了一个聚光灯与不同衰减项生成的光锥。图A展示了无衰减的光锥，图B展示了以距离倒数为衰减系数的光锥，图C展示了距离平方倒数为衰减系数的光锥，这效果与现实世界的效果相当。在我们粒子中，我们选择增加一个环境项加到图C的效果中。
在本文其他剩余部分，我们将用三项系数去遮挡散射光的强度：light cookie，阴影和噪声。

光遮罩

在我们光照等式中第二个系数一般在光照阶段称为cookie或者gobo。是个简单的裁剪，用于让光照到场景中有一定的形状，在我们的例子中是空气中的漂浮颗粒物。不同的cookies可以令到容积光变成又去的样子，就像电影或者教堂那些一样。下图是些cookie的例子。

阴影

下一个用于遮罩散射光的系数是光照等式中的阴影。对光锥中任意3D点来说，我们可以知道这个点是否被场景其他部分的阴影笼罩这。实现这个任务最自然会想到shadowmap。为了创建shadowmap，我们需要从光源角度通过投影把场景深度渲染到一张单独的纹理中，我们需要每帧更新这张图。下图展示我们测试场景的典型的shadowmap。与光源的距离会保存成一个值，黑色代表近白色代表远。
当渲染容积光的时候，shadowmap通过透视纹理映射到取样平面上。在采样平面上插入光照空间的深度，然后可以针对每个采样平面的每个像素处的阴影深度图的值进行测试。假如插值的深度比阴影贴图的深度还大，那就代表这点被场景中的物体挡住了，以及散射光量乘以0来剔除。图表示光照等式中包括阴影的结果。通过阴影引起的光线条纹给人非常戏剧性的外观，特别是光或者观察者（或者两者同时）移动。

噪声

令容积光变得有趣和有体积感觉的简单方法是投影噪声到取样平面上。这给人颗粒物不均匀的感觉并且一般来说会增加视觉效果。在我们的例子中，两张重复的灰度噪声图，如图所示，会投影到采样平面并且在不同方向上慢慢移动。

混合两张噪声能给出一种容积光的动态效果。下图展示了场景用不用噪声图的区别。当然噪声有最好感觉的时候是移动的时候。

现在我们已经介绍为光照等式中的各种参数，我们现在可以看看像素着色器怎么计算出光体重每个取样最终的散射光强度。

从函数的原型可以看出，采样平面上插值了三组投影纹理坐标，分别是shadowmap和两张噪声纹理。除了这些投影纹理坐标，灯光空间坐标和灯光空间的深度都需要在另外一个纹理坐标中插值。这些在shader中会用来计算距离强度以及shadowmap的对比。最终插值的参数用做这笔，用于把最终正确的强度计算并写入到正确的output buffer通道中。这会在质量部分进行更多的讨论。

通过插值参数以后，你可以看到三个bool参数，用于定制化代码。这些输入在编译的时候已经知道（因为他们是uniform的），并且编译器用来优化我们的dead code。由于这个像素着色器是在D3DX Effects framework下 的，对于这个像素着色器给定技术生成器的特定版本通过传递一些BOOL给着色器来实现，如下图。
这技术使用shadowmap和cookie，但是不用noise。一个不用噪声取样或混合的特定版本着色器，通过编译器生成个并且通过应用程序使用，假如不需要噪声的时候。
回头看着色器本身，你可以看到不同的block通过if的括号使用三个bool来区分。这意味着只需要维护这一个主要的HLSL，尽管我们可能最终runtime需要很多个不同的着色器。
shader的第一个block，被一个uniform bool括起来的那部分，是cookie取样。默认来说，cookie的颜色是白色的，但这个默认的颜色可以通过bCook=true来覆盖。
后面的就是噪声贴图采样。你会注意到同一张贴图被不同的投影纹理坐标取样了两次。这是因为我们选择把我们的灰度噪声贴图分别放在一张噪声贴图的RG通道中，这样会更方便。这两个取样会被混合在一起，然后解析出我们所需要的通道数值。
噪声取样和混合后，我们选择性地对shadow map进行取样并且用它与插值得到的深度进行比较。假如shadowmap取样出的深度更靠近光，那么我们的取样点就是在阴影中，并且我们的shadow参数为0，反之为1。
由于我们都要计算距离强度，我们在代码中计算atten的值，这并不在任何BOOL控制的代码块中。由于我们的取样平面都是没有细分过的大四边形，我们不可以在顶点着色器中计算这个值并且对其插值，我们是插值三维灯光空间的坐标，并且在着色器中间计算距离平方倒数这个强度系数。然后我们有一些magic number 来调整效果以符合应用程序中显示的世界规模。参数scale适用于缩放每个取样平面的贡献。其中一个优化是，假如用户把光体移得很远，那就可以减少取样平面的数量，所以这个scale参数应该是动态的。最终，这些参数会被乘在一起，我们三个遮蔽参数（cookie、shadow和噪声）会遮蔽散射出来的光。像素着色器的最后一个操作是乘以一个4D向量称谓 ChannelMask。这有效地把我们的强度映射到渲染目标上。当我们提高这个效果的质量的时候，这个的动机会变得清楚。

质量

像之前讨论过的，这个技术基于沿着射线在包含光照信息的光体中取样。在图形学中，我们不断采样不同的信号，并且当我们采样时我们都要考虑抗锯齿。在光栅化硬边的多边形的时候的确是真的，或者对纹理的取样，因为它可以很有高频组件。当光栅化的时候，我们会对全屏幕抗锯齿多重采样，而当对贴图的时候我们会采用某种过滤来实现抗锯齿，例如mipmap三线性过滤。
类似的，当我们重构体数据的时候，我们必须小心每条射线太少的取样，或者错过高频分量，类似于shadowmap的边界。这意味着我们希望使用尽量多的采样平面来增加我们的采样频率。我们可以尝试过滤我们光照公式中的分量，为了减少取样平面，特别是shadowmap。在我们例子中，我们对投影shadowmap 使用消耗不大的最近取样的过滤方式。假如我们使用太少的取样平面，我们，没办法很好地重建阴影的边，并且会得到下图那样的梯度的样子。这两张图分别是25和50个采样平面的样子，说明了采样量不足的问题。后面的图是回执了100张取样平面，梯度的问题就消失了。
如上所述，为了对阴影的采样抗锯齿，我们想画尽量多的平面。在现今的图形结构，我们只能对每个通道最多8位的精度表面进行Alpha混合。所以加入我们绘制了很多取样平面，每个平面只能对frame buffer增加1到2位的数据。这会导致最终图像有带状的样子。
假如你只需要用单色的灯光，这里有个很简单的技巧可以提高精度。在我们的例子中，我们选择先渲染一张离线的RGBA图而不是直接渲染到back buffer。